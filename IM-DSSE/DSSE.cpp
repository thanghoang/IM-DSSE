
#include "MasterKey.h" 
#include "DSSE.h"
#include "Keyword_Extraction.h"    
#include "Miscellaneous.h" 
#include "DSSE_Trapdoor.h"     
#include "DSSE_Crypto.h"
#include "DSSE_KeyGen.h"
#include "climits"
#include "Client_DSSE.h"
#include "math.h"
DSSE::DSSE()
{
    //register the PRNG with Fortuna
     
    int err;
    if ((err = register_prng(&fortuna_desc)) != CRYPT_OK) 
    {
		printf("Error registering Fortuna PRNG : %s\n", error_to_string(err));
	}

	if ((err = find_prng("fortuna")) != CRYPT_OK) 
    {
		printf("Invalid PRNG : %s\n", error_to_string(err));
	}

	/* start it */
	if ((err = fortuna_start(&prng)) != CRYPT_OK) 
    {
		printf("Start error: %s\n", error_to_string(err));
	}

	if ((err = fortuna_add_entropy((unsigned char*)seed.c_str(), seed.size(), &prng)) != CRYPT_OK) 
    {
		printf("Add_entropy error: %s\n", error_to_string(err));
	}
    if ((err = fortuna_ready(&prng)) != CRYPT_OK) 
    {
		printf("Ready error: %s\n", error_to_string(err));
	}
}

DSSE::~DSSE()
{
}

/**
 * Function Name: setupData_structure
 *
 * Description:
 * Buid all data structures needed for DSSE (incld. in client and server sides). The encrypted 
 * index is stored as files
 *
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param pKeywordCounterArray: (output) counter for each keyword
 * @param pBlockCounterArray: (output) counter for each file
 * @param pBlockStateMatrix: (output) state for each block
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param rFileName: (output) list of distinct files
 * @param path: (intput) location of file collection
 * @param pKey: (input) symmetric keys generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::setupData_structure(
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        TYPE_COUNTER *pKeywordCounterArray,
        TYPE_COUNTER *pBlockCounterArray,
        MatrixType **pBlockStateMatrix,
        vector<TYPE_INDEX> &lstFree_column_idx,
        vector<TYPE_INDEX> &lstFree_row_idx,
		vector<string> &rFileNames,
		string path,
		MasterKey *pKey)
{
	set<string>::iterator iter;
    
    unsigned char empty_label[6] = "EMPTY";
    unsigned char delete_label[7] = "DELETE";
    hashmap_key_class empty_key = hashmap_key_class(empty_label,6);
    hashmap_key_class delete_key = hashmap_key_class(delete_label,7);
    

	try
    {
        rT_W = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_KEYWORDS*KEYWORD_LOADING_FACTOR);
        rT_W.max_load_factor(KEYWORD_LOADING_FACTOR);
		rT_W.min_load_factor(0.0);
        rT_W.set_empty_key(empty_key);
		rT_W.set_deleted_key(delete_key);

		rT_F = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_OF_FILES*KEYWORD_LOADING_FACTOR);
        rT_F.max_load_factor(FILE_LOADING_FACTOR);
		rT_F.min_load_factor(0.0);
		rT_F.set_empty_key(empty_key);
		rT_F.set_deleted_key(delete_key);
        
        lstFree_column_idx.reserve(MAX_NUM_OF_FILES);
        lstFree_column_idx.clear();
        lstFree_row_idx.reserve(MAX_NUM_KEYWORDS);
        lstFree_row_idx.clear();
        
        for(TYPE_INDEX j = 0 ; j < MAX_NUM_KEYWORDS; j++)
            lstFree_row_idx.push_back(j);
        for (TYPE_INDEX j = 0 ; j < MAX_NUM_OF_FILES; j++)
            lstFree_column_idx.push_back(j);        
        for(TYPE_INDEX i = 0 ; i < MAX_NUM_KEYWORDS;i++)
            pKeywordCounterArray[i] = 1;
        for(TYPE_INDEX i = 0 ; i < MAX_NUM_OF_FILES/ENCRYPT_BLOCK_SIZE;i++)
            pBlockCounterArray[i] = 1;

        printf("   1.0 Scanning whole database first....");
        this->scanDatabase(rFileNames,keywords_dictionary,rT_W,rT_F,path,pKey);
        if(keywords_dictionary.size() >= MAX_NUM_KEYWORDS)
        {
            printf("Error!\n The encrypted index size is not enough to handle all keywords in the DB, please increase the MAX_NUM_KEYWORDS in config.h\n");
            exit(1);
        }
        
        if (rFileNames.size() >= MAX_NUM_OF_FILES)
        {
            printf("Error!\n The encrypted index size is not enough to handle all files in the DB, please increase the MAX_NUM_OF_FILES in config.h\n");
            exit(1);
        }
        printf("OK!\n");
        cout<<"# unique kw: "<<keywords_dictionary.size()<<endl;
        cout<<"# unique files: "<<rFileNames.size()<<endl;

        printf("   1.1. Creating keyword and file pairs...");
        vector<vector<TYPE_INDEX>> kw_file_pair;
        kw_file_pair.reserve(MAX_NUM_OF_FILES);
        for(TYPE_INDEX col = 0 ; col <MAX_NUM_OF_FILES; col++)
        {
            vector<TYPE_INDEX> tmp;
            kw_file_pair.push_back(tmp);
        }
        auto start = time_now;
        this->createKeyword_file_pair(kw_file_pair,rT_W,rT_F,lstFree_row_idx, lstFree_column_idx, path,pKey);
        printf("OK!\n");
        printf("   1.1. Creating encrypted matrix...");
        this->createEncrypted_matrix_from_kw_file_pair(kw_file_pair, pKeywordCounterArray,pBlockCounterArray,pKey);
		printf("OK!\n");
        auto end = time_now;
        cout<<"BUILDING TIME: "<<std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count()<<" ms"<<endl;
    #if !defined(DECRYPT_AT_CLIENT_SIDE)
        printf("   1.2. Creating block state matrix...");
        this->createBlock_state_matrix_files();
        printf("OK!\n");
    #endif
    
            
	}
    catch(exception &e)
    {
		printf("Error!\n");
        exit(1);
	}


	return 0;
}

/**
 * Function Name: searchToken
 *
 * Description:
 * generate search token given a keyword being searched
 *
 * @param pSearchToken: (output) generated search token
 * @param keyword: (input) keyword being searched
 * @param pKeywordCounterArray: (input) keyword counters
 * @param pKey: (input) symmetric keys for data structure encryption
 * @return	0 if successful
 */
int DSSE::searchToken(SEARCH_TOKEN &pSearchToken,
		string keyword,
        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
        TYPE_COUNTER *pKeywordCounterArray,
		MasterKey *pKey) 
{
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE] = {'\0'};
    TYPE_COUNTER keyword_counter;
    unsigned char row_key_input[BLOCK_CIPHER_SIZE] = {'\0'};
    
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen();
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    Miscellaneous misc;
	try
    {
        /* Generates the trapdoor for the keyword to be searched */
        int keyword_length = strlen(keyword.c_str());
        
        dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)keyword.c_str(), keyword_length, pKey);
        
        hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
        if(rT_W[hmap_keyword_trapdoor]!=NULL)
            pSearchToken.row_index = rT_W[hmap_keyword_trapdoor];
        else
        {
            pSearchToken.row_index = KEYWORD_NOT_EXIST;
            return 0;
        }
        if(pKeywordCounterArray[pSearchToken.row_index] == ULONG_MAX)
        {
            printf("Error! counter limit exceeded");
            exit(1);
        }
        keyword_counter = pKeywordCounterArray[pSearchToken.row_index];
        memset(row_key_input,0,sizeof(row_key_input));
        memcpy(row_key_input,&pSearchToken.row_index,sizeof(pSearchToken.row_index));
        memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));

        dsse_keygen->genRow_key(pSearchToken.row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
        
        if(pKeywordCounterArray[pSearchToken.row_index]>1)
        {

            keyword_counter = pKeywordCounterArray[pSearchToken.row_index] - 1 ;
            memset(row_key_input,0,sizeof(row_key_input));
            memcpy(row_key_input,&pSearchToken.row_index,sizeof(pSearchToken.row_index));
            memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
            dsse_keygen->genRow_key(pSearchToken.row_old_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
            
            pSearchToken.hasRow_key = true;
        }
        else
        {
            memset(pSearchToken.row_old_key,0,BLOCK_CIPHER_SIZE);
            pSearchToken.hasRow_key = false;
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
		exit(1);
    }

    memset(keyword_trapdoor,0,TRAPDOOR_SIZE);
    memset(row_key_input,0,BLOCK_CIPHER_SIZE);
    delete dsse_keygen;
    delete dsse_trapdoor;
	return 0;
}
/**
 * Function Name: search
 *
 * Description:
 * Perform keyword search over DSSE encrypted data structure, given a search token
 *
 * @param rFileIDs: (output) list of file ids in which the keyword being searched appears 
 * @param pSearchToken: (input) search token
 * @param I: (input) encrypted data structure
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateMatrix: (input) block states
 * @return	0 if successful
 */

int DSSE::search(   vector<TYPE_INDEX> &rFileIDs,
                    SEARCH_TOKEN pSearchToken,
                    MatrixType **I,
                    TYPE_COUNTER *pBlockCounterArray,
                    MatrixType **pBlockStateMatrix)
{
	TYPE_INDEX row = 0, col = 0;
    TYPE_INDEX index = 0;
    int bit_number = 0, bit_value = 0, file_index = 0;
	vector<unsigned char>file_list;
	unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    Miscellaneous misc;
    bool need_reencrypt;
    
    TYPE_INDEX block_idx;
    int ii,jj;
    if( pSearchToken.row_index< 0)
    {
        printf("Error!!\n");
        exit(1);
    }
	try
    {
        rFileIDs.clear();
        file_list.reserve(MATRIX_COL_SIZE);
		
        /* Get the row index for the keyword being searched */
		row = pSearchToken.row_index;
        /* Decrypt blocks */
        for(index = 0, block_idx = 0; index < MAX_NUM_OF_FILES; index+=ENCRYPT_BLOCK_SIZE,block_idx++)
        {
            col = index / BYTE_SIZE;
            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
            {
                bit_number = index % BYTE_SIZE;
                for(ii=0 ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
                {
                    if(BIT_CHECK(&I[row][col].byte_data,bit_number))
                        BIT_SET(&V[0],ii);
                    else
                        BIT_CLEAR(&V[0],ii);
                }
            }
            else
            {
                for(jj = col,ii=0; ii<ENCRYPT_BLOCK_SIZE/BYTE_SIZE;jj++, ii++)
                {
                    V[ii] = I[row][jj].byte_data;
                }
            }
            memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
            memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_idx],sizeof(TYPE_COUNTER));
            memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
                
            if(pSearchToken.hasRow_key == false || BIT_CHECK(&pBlockStateMatrix[row][block_idx/BYTE_SIZE].byte_data,block_idx%BYTE_SIZE))
            {
                aes128_ctr_encdec(V, U, pSearchToken.row_key, uchar_counter, ONE_VALUE);
                need_reencrypt = false;
            }
            else
            {
                aes128_ctr_encdec(V, U, pSearchToken.row_old_key, uchar_counter, ONE_VALUE);
                need_reencrypt = true;
            }
            
            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE) 
            {
                 for(ii=0; ii< ENCRYPT_BLOCK_SIZE;ii++)
                {
                    if(BIT_CHECK(&U[0],ii))
                        rFileIDs.push_back((index+ii));
                }
            }
            else
            {
                for(ii=0; ii<ENCRYPT_BLOCK_SIZE/BYTE_SIZE; ii++)
                {
                    for(bit_number = 0 ; bit_number<BYTE_SIZE; bit_number++)
                        if(BIT_CHECK(&U[ii],bit_number))
                            rFileIDs.push_back(index+ii*BYTE_SIZE+bit_number);
                }
            }
           
            /* Set the state bit of this block to 0 */
            BIT_CLEAR(&pBlockStateMatrix[row][block_idx/BYTE_SIZE].byte_data,block_idx%BYTE_SIZE);
            
            /* Re-encrypt the block with the newest row key if the old row key is used to decrypt before */
            if(need_reencrypt == true)
            {
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_idx],sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
                    
                aes128_ctr_encdec(U, V, pSearchToken.row_key, uchar_counter, ONE_VALUE);
            
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE) // block size < byte size
                {
                    bit_number = index % BYTE_SIZE;
                    for(ii=0 ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
                    {
                        if(BIT_CHECK(&V[0],ii))
                            BIT_SET(&I[row][col].byte_data,bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data,bit_number);
                    }
                }
                else
                {
                    for(jj = col,ii=0; ii<ENCRYPT_BLOCK_SIZE/BYTE_SIZE;jj++, ii++)
                    {
                        I[row][jj].byte_data = V[ii];
                    }
                }
            }
        }
		file_list.clear();
	}
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

	file_list.clear();
	memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
    memset(U,0,BLOCK_CIPHER_SIZE);
    memset(V,0,BLOCK_CIPHER_SIZE);
    
	return 0;
}

/**
 * Function Name: addToken
 *
 * Description:
 * Generate a token for adding file
 *
 * @param new_adding_file_with_path: (input) full filename and path of the adding file
 * @param I_prime: (output) block_data after adding the file
 * @param file_index: (output) index of adding file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param extracted_keyword: (output) uniques keyword being extracted from adding file
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::addToken(     string new_adding_file_with_path,
                        MatrixType* I_prime,                 
                        TYPE_INDEX &file_index, 
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                        TYPE_KEYWORD_DICTIONARY &extracted_keywords,
                        TYPE_COUNTER *pKeywordCounterArray,
                        TYPE_COUNTER *pBlockCounterArray,
                        bool *pBlockStateArray,
                        vector<TYPE_INDEX> &lstFree_column_idx,
                        vector<TYPE_INDEX> &lstFree_row_idx,
                        MasterKey* pKey)
{


    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen(); 
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX keyword_index;
    TYPE_INDEX row,col;
    
    TYPE_INDEX idx,ii;
    
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
    
    TYPE_INDEX selectedIdx;
    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction* kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType* I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];


    try
    {
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)new_adding_file_with_path.c_str(), 
                                    new_adding_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor]==NULL)
        {
            this->pickRandom_element(selectedIdx,lstFree_column_idx,&prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        
        /* Extract unique keywords */
        kw_ex->extractKeywords(extracted_keywords, new_adding_file_with_path, "");
        
        for(iter=extracted_keywords.begin();iter != extracted_keywords.end();iter++) 
        {
            string word = *iter;
            int keyword_len = word.size();

            if(keyword_len>0)
            {
                dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
                                        (unsigned char *)word.c_str(), keyword_len, pKey);
            }
                
            hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
            
            if(rT_W[hmap_keyword_trapdoor]==NULL)
            {
                this->pickRandom_element(selectedIdx,lstFree_row_idx,&prng);
                rT_W[hmap_keyword_trapdoor] = selectedIdx;
            }
            
            keyword_index = rT_W[hmap_keyword_trapdoor];
            row = keyword_index / BYTE_SIZE;
            bit_position = keyword_index %BYTE_SIZE;

            BIT_SET(&I_bar[row].byte_data,bit_position);
            
            word.clear();
        }
        
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE; 
        bit_position = file_index % BYTE_SIZE;
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index] + 1;
        
        
        if(ENCRYPT_BLOCK_SIZE>1) //decrypt the received I' to update the new data representation I_bar to I'
        {
            /*
             * 1.(a-c)Decrypt the whole data block I' to be I_bar using block key and the corresponding row key 
             * */
            for(I_bar_idx = 0 , idx = 0, size = MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE;idx < size; idx+=ENCRYPT_BLOCK_SIZE, I_bar_idx++)
            {
                row = idx / ENCRYPT_BLOCK_SIZE;
                I_bar_row = I_bar_idx / BYTE_SIZE;
                I_bar_bit_position = I_bar_idx % BYTE_SIZE;
                // *****************  FIX THE ERROR OF VARIANT 1 SHOWN IN THE SAC 2015 **********************
                // if the counter > 1 and the row has not been updated right before, generate the old row key to decrypt it
                if(pKeywordCounterArray[row]>1 && pBlockStateArray[row]==ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row]-1;
                }
                else
                {
                    keyword_counter = pKeywordCounterArray[row];
                }
                memset(row_key_input,0,sizeof(row_key_input));
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
                
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_index],sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE,col=idx/BYTE_SIZE,ii=0 ; ii < ENCRYPT_BLOCK_SIZE;ii++,bit_position++)
                    {
                        if(BIT_CHECK(&I_prime[col].byte_data,bit_position))
                            BIT_SET(&U[0],ii);
                        else
                            BIT_CLEAR(&U[0],ii);
                    }
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    
                    bit_position = file_index % ENCRYPT_BLOCK_SIZE;
        
                    if(BIT_CHECK(&I_bar[I_bar_row].byte_data,I_bar_bit_position))
                        BIT_SET(&V[0],bit_position);
                    else
                        BIT_CLEAR(&V[0],bit_position);
                }
                else
                {
                    for(ii = 0 ; ii <ENCRYPT_BLOCK_SIZE/BYTE_SIZE;ii++)
                        U[ii] = I_prime[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data;
                     
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    
                    //Update decrypted I_prime (V) by I_bar
                    ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE; 
                    bit_position = file_index % BYTE_SIZE;
                    
                    if(BIT_CHECK(&I_bar[I_bar_row].byte_data,I_bar_bit_position))
                        BIT_SET(&V[ii],bit_position);
                    else
                        BIT_CLEAR(&V[ii],bit_position);
                }
                //Re-encrypt V to U with new key and new counter
                if(pKeywordCounterArray[row]>1 && pBlockStateArray[row]==ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row];
                    memset(row_key_input,0,sizeof(row_key_input));
                    memcpy(row_key_input,&row,sizeof(row));
                    memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
                    dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                    
                }
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                aes128_ctr_encdec(V, U, row_key, uchar_counter, ONE_VALUE);
                
                // put U back to I_prime
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE, col=idx/BYTE_SIZE, ii=0 ; ii < ENCRYPT_BLOCK_SIZE;ii++,bit_position++)
                    {
                        if(BIT_CHECK(&U[0],ii))
                            BIT_SET(&I_prime[col].byte_data,bit_position);
                        else
                            BIT_CLEAR(&I_prime[col].byte_data,bit_position);
                    }
                }
                else
                {
                    for(ii = 0 ; ii <ENCRYPT_BLOCK_SIZE/BYTE_SIZE;ii++)
                             I_prime[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data = U[ii];
                }
            }
        }
        else
        {
            for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
            {
                keyword_counter = pKeywordCounterArray[row];
                memset(row_key_input,0,sizeof(row_key_input));
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));

                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                I_bar_row = row / BYTE_SIZE;
                I_bar_bit_position = row % BYTE_SIZE;
                if(BIT_CHECK(&I_bar[I_bar_row].byte_data,I_bar_bit_position))
                    BIT_SET(&U[0],0);
                else
                    BIT_CLEAR(&U[0],0);

                aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                
                if(BIT_CHECK(&V[0],0))
                    BIT_SET(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
                else
                    BIT_CLEAR(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
            }
            memcpy(I_prime,I_bar,MATRIX_ROW_SIZE/BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;
   
    return 0;
}

/**
 * Function Name: addToken
 *
 * Description:
 * Update block data for adding file using precomputed keys 
 * (This function is used when the DECRYPT_AT_CLIENT_SIDE macro is enabled)
 *
 * @param new_adding_file_with_path: (input) full filename and path of the adding file
 * @param I_prime: (output) block_data after adding the file
 * @param file_index: (output) index of adding file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param extracted_keyword: (output) uniques keyword being extracted from adding file
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param decrypt_key_arr: (input)keys used to decrypt input data
 * @param reencrypt_key_arr: (input) keys used to re-encrypt updated data
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::addToken(     string new_adding_file_with_path,
                        MatrixType* I_prime,
                        TYPE_INDEX &file_index, 
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                        TYPE_KEYWORD_DICTIONARY &extracted_keywords,
                        unsigned char* decrypt_key_arr,
                        unsigned char* reencrypt_key_arr,
                        vector<TYPE_INDEX> &lstFree_column_idx,
                        vector<TYPE_INDEX> &lstFree_row_idx,
                        MasterKey* pKey)
{
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen(); 
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX keyword_index;
    TYPE_INDEX row;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
    
    TYPE_INDEX selectedIdx;
    KeywordExtraction* kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType* I_bar;
    MatrixType* decrypted_block ;


    try
    {   
        decrypted_block = new MatrixType[MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE];
        
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)new_adding_file_with_path.c_str(), 
                                    new_adding_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor]==NULL)
        {
            this->pickRandom_element(selectedIdx,lstFree_column_idx,&prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        
        /* Extract unique keywords */
        kw_ex->extractKeywords(extracted_keywords, new_adding_file_with_path, "");
        
        for(iter=extracted_keywords.begin();iter != extracted_keywords.end();iter++) 
        {
            string word = *iter;
            int keyword_len = word.size();

            if(keyword_len>0)
            {
                dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
                                        (unsigned char *)word.c_str(), keyword_len, pKey);
            }
            hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
            if(rT_W[hmap_keyword_trapdoor]==NULL)
            {
                this->pickRandom_element(selectedIdx,lstFree_row_idx,&prng);
                rT_W[hmap_keyword_trapdoor] = selectedIdx;
            }
            keyword_index = rT_W[hmap_keyword_trapdoor];
            row = keyword_index / BYTE_SIZE;
            bit_position = keyword_index %BYTE_SIZE;

            BIT_SET(&I_bar[row].byte_data,bit_position);
            
            word.clear();
        }
        file_index = rT_F[hmap_file_trapdoor];
        
        if(ENCRYPT_BLOCK_SIZE > 1)
        {
            //decrypt the input block first
            memset(decrypted_block,0,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
            dsse_keygen->enc_dec_preAESKey(decrypted_block,I_prime,decrypt_key_arr,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
        
            //update the decrypted block with newly adding file block
            this->updateBlock(I_bar,decrypted_block,file_index);
        
            //reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(I_prime,decrypted_block,reencrypt_key_arr,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
        }
        else
        {
            dsse_keygen->enc_dec_preAESKey(I_prime,I_bar,reencrypt_key_arr,MATRIX_ROW_SIZE/BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }


    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete decrypted_block;
    delete I_bar;
   
    return 0;
}



/**
 * Function Name: delToken
 *
 * Description:
 * Generate a token for deleting file
 *
 * @param del_file_with_path: (input) full filename and path of the deleting file
 * @param I_prime: (output) block_data after deleting the file
 * @param file_index: (output) index of deleting file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::delToken(string del_file_with_path,
			  MatrixType* I_prime,
			  TYPE_INDEX &file_index,
              TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
              TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
              TYPE_COUNTER *pKeywordCounterArray,
              TYPE_COUNTER *pBlockCounterArray,
              bool *pBlockStateArray,
              vector<TYPE_INDEX> &lstFree_column_idx,
              vector<TYPE_INDEX> &lstFree_row_idx,
              MasterKey* pKey){

DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen(); 
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row,col;
    
    TYPE_INDEX idx,ii;
    
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    
    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction* kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType* I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];
    

    try
    {
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)del_file_with_path.c_str(), 
                                    del_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index] + 1;
        
        /* Remove the file trapdoor entry from the file hashmap */
        lstFree_column_idx.push_back(file_index);
        rT_F.erase(hmap_file_trapdoor);
        
        if(ENCRYPT_BLOCK_SIZE>1) //decrypt the received I' to update the new data representation I_bar to I'
        {
            /* Decrypt the whole data block I' to be I_bar using block key and the corresponding row key  */
            for(I_bar_idx = 0 , idx = 0, size = MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE;idx < size; idx+=ENCRYPT_BLOCK_SIZE, I_bar_idx++)
            {
                row = idx / ENCRYPT_BLOCK_SIZE;
                I_bar_row = I_bar_idx / BYTE_SIZE;
                I_bar_bit_position = I_bar_idx % BYTE_SIZE;
                // *****************  FIX THE ERROR OF VARIANT 1 SHOWN IN THE SAC 2015 **********************
                // if the counter > 1 and the row has not been updated right before, generate the old row key to decrypt it
                if(pKeywordCounterArray[row]>1 && pBlockStateArray[row]==ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row]-1; // rk_stream = input of G_k3 ( i || st_i )
                }
                else
                {
                    keyword_counter = pKeywordCounterArray[row];
                }
                memset(row_key_input,0,sizeof(row_key_input));
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_index],sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    for(bit_position = idx % BYTE_SIZE,col=idx/BYTE_SIZE,ii=0 ; ii < ENCRYPT_BLOCK_SIZE;ii++,bit_position++)
                    {
                        if(BIT_CHECK(&I_prime[col].byte_data,bit_position))
                            BIT_SET(&U[0],ii);
                        else
                            BIT_CLEAR(&U[0],ii);
                    }
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    
                    //Update decrypted I_prime (V) by 0
                    bit_position = file_index % ENCRYPT_BLOCK_SIZE;
                    BIT_CLEAR(&V[0],bit_position);
                }
                else
                {
                    for(ii = 0 ; ii <ENCRYPT_BLOCK_SIZE/BYTE_SIZE;ii++)
                        U[ii] = I_prime[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data;
                     
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    
                    //Update decrypted I_prime (V) by 0
                    ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE; 
                    bit_position = file_index % BYTE_SIZE;
                    
                    BIT_CLEAR(&V[ii],bit_position);
                }
                //Re-encrypt V to U with new key and new counter
                if(pKeywordCounterArray[row]>1 && pBlockStateArray[row]==ZERO_VALUE)
                {
                    keyword_counter = pKeywordCounterArray[row];
                    memset(row_key_input,0,sizeof(row_key_input));
                    memcpy(row_key_input,&row,sizeof(row));
                    memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
                    
                    dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                    
                }
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                aes128_ctr_encdec(V, U, row_key, uchar_counter, ONE_VALUE);
                
                // put U back to I_prime
                if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
                {
                    //write the decrypted V back 
                    for(bit_position = idx % BYTE_SIZE, col=idx/BYTE_SIZE, ii=0 ; ii < ENCRYPT_BLOCK_SIZE;ii++,bit_position++)
                    {
                        if(BIT_CHECK(&U[0],ii))
                            BIT_SET(&I_prime[col].byte_data,bit_position);
                        else
                            BIT_CLEAR(&I_prime[col].byte_data,bit_position);
                    }
                }
                else
                {
                    for(ii = 0 ; ii <ENCRYPT_BLOCK_SIZE/BYTE_SIZE;ii++)
                             I_prime[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data = U[ii];
                }
            }
        }
        else
        {
            for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
            {
                keyword_counter = pKeywordCounterArray[row];
                memset(row_key_input,0,sizeof(row_key_input));
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
                memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
                
                I_bar_row = row / BYTE_SIZE;
                I_bar_bit_position = row % BYTE_SIZE;
                
                BIT_CLEAR(&U[0],0);
                //encrypt
                aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                
                if(BIT_CHECK(&V[0],0))
                    BIT_SET(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
                else
                    BIT_CLEAR(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
            }
            memcpy(I_prime,I_bar,MATRIX_ROW_SIZE/BYTE_SIZE);
            
        }
        
    }
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;
   
    return 0;    
}

/**
 * Function Name: delToken
 *
 * Description:
 * Update block data for deleting file
 * (This function is used when the DECRYPT_AT_CLIENT_SIDE macro is enabled)
 *
 * @param del_file_with_path: (input) full filename and path of the deleting file
 * @param I_prime: (output) block_data after deleting the file
 * @param file_index: (output) index of deleting file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param decrypt_key_arr: (input)keys used to decrypt input data
 * @param reencrypt_key_arr: (input) keys used to re-encrypt updated data
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::delToken(string del_file_with_path,
                MatrixType* I_prime,
                TYPE_INDEX &file_index,
                TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                unsigned char* decrypt_key_arr,
                unsigned char* reencrypt_key_arr,
                vector<TYPE_INDEX> &lstFree_column_idx,
                vector<TYPE_INDEX> &lstFree_row_idx,
                MasterKey* pKey)
{
    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    Miscellaneous misc;
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen();
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    MatrixType* decrypted_block;
    MatrixType* I_bar;
    try
    {
        
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)del_file_with_path.c_str(), 
                                    del_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        
        file_index = rT_F[hmap_file_trapdoor];

        
        /* Remove the file trapdoor entry from the file hashmap */
        lstFree_column_idx.push_back(file_index);
        rT_F.erase(hmap_file_trapdoor);
        
        
        if(ENCRYPT_BLOCK_SIZE > 1)
        {
                //decrypt the input block first
            decrypted_block = new MatrixType[MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE];
            memset(decrypted_block,0,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
            dsse_keygen->enc_dec_preAESKey(decrypted_block,I_prime,decrypt_key_arr,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
            
            //update the decrypted block with 0-block
            this->updateBlock(I_bar,decrypted_block,file_index);
        
            //reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(I_prime,decrypted_block,reencrypt_key_arr,MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
            delete decrypted_block;
        }
        else
        {
            //reencrypt the updated blocks with reenncryption key
            dsse_keygen->enc_dec_preAESKey(I_prime,I_bar,reencrypt_key_arr,MATRIX_ROW_SIZE/BYTE_SIZE);
        }
    }
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete I_bar;
    delete dsse_keygen;
   
    return 0;    
}


/**
 * Function Name: update
 *
 * Description:
 * Update the DSSE encrypted data structure, given a adding-file/deleting-file token
 *
 * @param I_prime: (input) block data being updated
 * @param block_index: (input) index of the block being updated
 * @param I: (output) DSSE encrypted data structure after update
 * @param pBlockCounterArray: (output) Block counters
 * @param pBlockStateMatrix: (output) block states
 * @return	0 if successful
 */
int DSSE::update(MatrixType* I_prime,              
            TYPE_INDEX block_idx,
            MatrixType** I,
            TYPE_COUNTER *pBlockCounterArray,
            MatrixType **pBlockStateMatrix)
            
{
    TYPE_INDEX row, col;
    TYPE_INDEX idx;
    TYPE_INDEX begin,end;
    TYPE_INDEX I_prime_bit_idx,I_prime_col_idx;
    TYPE_INDEX bit_position;
    TYPE_INDEX bit_number;
    try
    {
    
        if(ENCRYPT_BLOCK_SIZE>1)
        {
            if(ENCRYPT_BLOCK_SIZE>BYTE_SIZE)
            {
                begin = block_idx*ENCRYPT_BLOCK_SIZE/BYTE_SIZE;
                end = block_idx*ENCRYPT_BLOCK_SIZE/BYTE_SIZE + ENCRYPT_BLOCK_SIZE / BYTE_SIZE;
                idx = 0;
                for (row=0;row<MATRIX_ROW_SIZE; row++)
                {
                    for(col = begin; col < end; col++,idx++)
                    {
                        I[row][col].byte_data = I_prime[idx].byte_data;
                    }
                }
            }
            else
            {
                col = block_idx*ENCRYPT_BLOCK_SIZE /BYTE_SIZE;
                bit_position = (block_idx*ENCRYPT_BLOCK_SIZE)%BYTE_SIZE;
                idx = 0;
                for (row=0;row<MATRIX_ROW_SIZE; row++)
                {
                    for(bit_number = bit_position ;bit_number< bit_position + ENCRYPT_BLOCK_SIZE; bit_number++,idx++)
                    {
                        I_prime_col_idx = idx / BYTE_SIZE;
                        I_prime_bit_idx = idx % BYTE_SIZE;
                        if(BIT_CHECK(&I_prime[I_prime_col_idx].byte_data,I_prime_bit_idx))
                            BIT_SET(&I[row][col].byte_data,bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data,bit_number);
                    }
                }
                
            }
        }
        else
        {
            col = block_idx / (BYTE_SIZE);
            bit_position = block_idx % BYTE_SIZE;
            for (row=0,idx=0;row<MATRIX_ROW_SIZE; row++,idx++)
            {
                I_prime_bit_idx = idx % BYTE_SIZE;
                I_prime_col_idx = idx / BYTE_SIZE;
                if(BIT_CHECK(&I_prime[I_prime_col_idx].byte_data,I_prime_bit_idx))
                    BIT_SET(&I[row][col].byte_data,bit_position);
                else
                    BIT_CLEAR(&I[row][col].byte_data,bit_position);
            }
        }
        /* Iset the counter of this block to+1, set the state of the block to 1.*/
#if !defined(DECRYPT_AT_CLIENT_SIDE)
        if(pBlockCounterArray!=NULL)
            pBlockCounterArray[block_idx] += 1;
        if(pBlockStateMatrix !=NULL)
        {
            TYPE_INDEX col = block_idx/ BYTE_SIZE;
            TYPE_INDEX bit = block_idx % BYTE_SIZE;
            for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
            {
                BIT_SET(&pBlockStateMatrix[row][col].byte_data,bit);
            }
        }
#endif
    }
    catch(exception & e)
    {
        printf("Error!!\n");
        exit(1);
    }

    return 0;
}



/**
 * Function Name: updateBlock
 * 
 * Description:
 * Update the input block with a new column data
 *
 * @param updating_block: (input) the new data which will be used to update a column data in the input block
 * @param input_block: (input) block going to be updated
 * @param update_idx: (input) the index of columns which will be updated in the input block
 * @return	0 if successful
 */
 
int DSSE::updateBlock(  MatrixType* updating_block,
                        MatrixType* input_block,
                        TYPE_INDEX update_idx)
{
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row,col;
    TYPE_INDEX idx,ii,size;
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
    if(ENCRYPT_BLOCK_SIZE>1)
    {
        for(I_bar_idx = 0 , idx = 0, size = MATRIX_ROW_SIZE*ENCRYPT_BLOCK_SIZE;idx < size; idx+=ENCRYPT_BLOCK_SIZE, I_bar_idx++)
        {
            col=idx/BYTE_SIZE;
            row = idx / ENCRYPT_BLOCK_SIZE;
            I_bar_row = I_bar_idx / BYTE_SIZE;
            I_bar_bit_position = I_bar_idx % BYTE_SIZE;
            
            if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE)
            {
                bit_position = (idx % BYTE_SIZE) + (update_idx % ENCRYPT_BLOCK_SIZE);
    
                if(BIT_CHECK(&updating_block[I_bar_row].byte_data,I_bar_bit_position))
                    BIT_SET(&input_block[col].byte_data,bit_position);
                else
                    BIT_CLEAR(&input_block[col].byte_data,bit_position);
            }
            else
            {
                //Update decrypted I_prime (V) by I_bar
                ii = (update_idx % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE; 
                bit_position = update_idx % BYTE_SIZE;
                
                if(BIT_CHECK(&updating_block[I_bar_row].byte_data,I_bar_bit_position))
                    BIT_SET(&input_block[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data,bit_position);
                else
                    BIT_CLEAR(&input_block[row*(ENCRYPT_BLOCK_SIZE/BYTE_SIZE)+ii].byte_data,bit_position);
            }
        }
    }
    else
    {
        memcpy(input_block,updating_block,MATRIX_ROW_SIZE/BYTE_SIZE);
        
    }
    return 0;
}


/**
 * Function Name: requestBlock_index
 *
 * Description:
 * generate the block index, given a name of file being added
 *
 * @param adding_filename_with_pad: (input) full path and name of the file being added
 * @param block_index: (output) block index of the adding file
 * @param rT_F: (input) file hash table
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::requestBlock_index(   string adding_filename_with_pad,
                                TYPE_INDEX &block_index,
                                TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                                vector<TYPE_INDEX> &lstFree_column_idx,
                                MasterKey *pKey)       
{       
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    TYPE_INDEX file_index;
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    TYPE_INDEX selectedIdx;
    try
    {
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)adding_filename_with_pad.c_str(), 
                                    adding_filename_with_pad.size(), pKey);
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor] == NULL)
        {
            this->pickRandom_element(selectedIdx,lstFree_column_idx,&prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        // Get the file index from the hashmap
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index/ENCRYPT_BLOCK_SIZE;
        if(block_index > NUM_BLOCKS)
        {
            printf("Error!!\n");
            exit(1);
        }
    }
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    delete dsse_trapdoor;
    return 0;
}


/**
 * Function Name: pickRandom_element
 *
 * Description:
 * Uniformly select an element at random from a set
 *
 * @param random_element: (output) element being picked
 * @param setIdx: (input) set of indices
 * @param prng: pseudo-random number state according to libtomcrypt
 * @return	0 if successful
 */
 
int DSSE::pickRandom_element(TYPE_INDEX &random_element, vector<TYPE_INDEX> &setIdx,prng_state* prng)
{
    TYPE_INDEX random_idx;
    unsigned char pseudo_random_number [BLOCK_CIPHER_SIZE];
    int seed_len = BLOCK_CIPHER_SIZE ; 
	int error = 0;
   
    TYPE_INDEX tmp;
    
    memset(pseudo_random_number,0,BLOCK_CIPHER_SIZE);               
	
    // Generate random number 
    fortuna_read(pseudo_random_number, BLOCK_CIPHER_SIZE, prng);
    
    memcpy(&tmp,&pseudo_random_number[7],sizeof(tmp)); // TAKE A HALF OF PSEUDO RANDOM NUMBER VARIABLE
    random_idx = tmp % setIdx.size();
    
    random_element = setIdx[random_idx];
    setIdx.erase(setIdx.begin()+random_idx);


    memset(pseudo_random_number,0,BLOCK_CIPHER_SIZE);
    return 0;
}

/**
 * Function Name: scanDatabase
 *
 * Description:
 * Scan the file collection to determine the total numbers of files and unique keywords being extracted, and to estimate the size of 2 hash tables at client
 *
 * @param rFileName: (output) list of files in the file collection
 * @param rKeywordDictionary: (output) list of unique keywords being extracted
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param path: (input) location of the file collection
 * @param pKey: (input) symmetric keys
 * @return	0 if successful
 */
int DSSE::scanDatabase(
		vector<string> &rFileNames,
		TYPE_KEYWORD_DICTIONARY &rKeywordsDictionary,
        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        string path,
        MasterKey* pKey)
{

	int keyword_len = 0;
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE], file_trapdoor[TRAPDOOR_SIZE];
	string word;
	DIR *pDir;
	struct dirent *pEntry;
	struct stat file_stat;
	string file_name, file_name_with_path;
	TYPE_KEYWORD_DICTIONARY words_per_file;
	set<string>::iterator iter;
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
	try
    {
		if((pDir=opendir(path.c_str())) != NULL)
        {
			while((pEntry = readdir(pDir))!=NULL)
            {
				file_name = pEntry->d_name;
				if(!file_name.compare(".") || !file_name.compare("..")) 
                {
					continue;
				}
				else
                {
					file_name_with_path = path + pEntry->d_name;                                      // "/" +

					// If the file is a directory (or is in some way invalid) we'll skip it
					if (stat(file_name_with_path.c_str(), &file_stat)) continue;

					if (S_ISDIR(file_stat.st_mode))
                    {
						file_name_with_path.append("/");
                        scanDatabase(rFileNames, rKeywordsDictionary, rT_W, rT_F, file_name_with_path,pKey);
						continue;
					}
                    if(file_name_with_path.size() > 0)
                    {
						dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
								(unsigned char *)file_name_with_path.c_str(), 
								file_name_with_path.size(), pKey);
                    }
					else
						printf("File name is empty\n");

					hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
                    
                    rT_F[hmap_file_trapdoor] = FILE_NOT_EXIST; // assign empty values to this
                    
					rFileNames.push_back(file_name_with_path.c_str());
            
                    KeywordExtraction* wordext = new KeywordExtraction(); 
					wordext->extractKeywords(words_per_file, file_name, path);

					for(iter=words_per_file.begin();iter != words_per_file.end();iter++) 
                    {
                        word = *iter;
						keyword_len = word.size();
                        if(keyword_len>0)
                        {
                            dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
									(unsigned char *)word.c_str(), keyword_len, pKey);
                            rKeywordsDictionary.insert(word);
                        }
						else
                        {
                            continue;
                        }
						hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor,TRAPDOOR_SIZE);
    
                        rT_W[hmap_keyword_trapdoor] = KEYWORD_NOT_EXIST;
                        
                        // Clearing contents
						word.clear();
					}
					// Clearing contents
					words_per_file.clear();
					file_name_with_path.clear();
				}
				// Clearing contents
				file_name.clear();
			}

			closedir(pDir);
		}
		else
        {
			cout << "Could not locate the directory..." << endl;
		}
	}
    catch(exception &e)
    {
		cout << "Error occurred in generate_file_trapdoors function " << e.what() << endl;
	}
	return 0;
}

/**
 * Function Name: createKeyword_file_pair
 *
 * Description:
 * create keyword-file pair from the file collection
 *
 * @param kw_file_pair: (output) list of keyword-file pair being extracted
 * @param rT_W: (output) keyword hash table 
 * @param rT_F: (output) file hash table
 * @param lstFree_keyword_idx: (input) list of empty indices used for keyword (e.g., empty row index)
 * @param lstFree_file_idx: (input) list of empty indices used for file (e.g., empty column index)
 * @param path: (input) location of the file collection
 * @param pKey: (input) key generated by genMasterKey which is used for hash table
 * @return	0 if successful
 */
int DSSE::createKeyword_file_pair(
        vector<vector<TYPE_INDEX>> &kw_file_pair,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        vector<TYPE_INDEX> &lstFree_keyword_idx,
        vector<TYPE_INDEX> &lstFree_file_idx,
		string path,
		MasterKey *pKey)
{
	int keyword_len = 0;
	TYPE_INDEX row = 0,file_index = 0;
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
	unsigned char file_trapdoor[TRAPDOOR_SIZE];
	string word;
	DIR *pDir;
	struct dirent *pEntry;
	struct stat file_stat;
	string file_name, file_name_with_path;
	TYPE_KEYWORD_DICTIONARY words_per_file;
	set<string>::iterator iter;

    KeywordExtraction* kw_ex = new KeywordExtraction();
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    
    TYPE_INDEX selectedIdx;
    try
    {
		if((pDir=opendir(path.c_str())) != NULL)
        {
			while((pEntry = readdir(pDir))!=NULL)
            {
				file_name = pEntry->d_name;
                // look into pEntry 
				if(!file_name.compare(".") || !file_name.compare("..")) 
                {
					continue;
				}
				else
                {
					file_name_with_path = path + pEntry->d_name; 
					// If the file is a directory (or is in some way invalid) we'll skip it
					if (stat(file_name_with_path.c_str(), &file_stat)) 
                        continue;
					if (S_ISDIR(file_stat.st_mode))
                    {
						file_name_with_path.append("/");
						createKeyword_file_pair(kw_file_pair, rT_W, rT_F, lstFree_keyword_idx, lstFree_file_idx, file_name_with_path, pKey);
						continue;
					}
					if(file_name_with_path.size() > 0)
                    {
						dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
								(unsigned char *)file_name_with_path.c_str(), 
								file_name_with_path.size(), pKey);
                    }
					else
						printf("File name is empty\n");

					hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
                    
					// Get the file index from the hashmap
                    if(rT_F[hmap_file_trapdoor] == FILE_NOT_EXIST)
                    {
                        this->pickRandom_element(selectedIdx,lstFree_file_idx,&prng);
                        rT_F[hmap_file_trapdoor] = selectedIdx;
                    }	
                   
                    kw_ex->extractKeywords(words_per_file, file_name, path);
                    
                    for(iter=words_per_file.begin();iter != words_per_file.end();iter++) 
                    {
						word = *iter;
						keyword_len = word.size();
                        if(keyword_len>0)
                        {
							dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
									(unsigned char *)word.c_str(), keyword_len, pKey);
                        }
						else
                        {
                            continue;
                        }
						hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor,TRAPDOOR_SIZE);
    
                        if(rT_W[hmap_keyword_trapdoor] == KEYWORD_NOT_EXIST)
                        {
                            this->pickRandom_element(selectedIdx,lstFree_keyword_idx,&prng);
                            rT_W[hmap_keyword_trapdoor] = selectedIdx;
                            
                        }

                        row = rT_W[hmap_keyword_trapdoor];

                        file_index = rT_F[hmap_file_trapdoor];
                        
                        //build the keyword file pair
                        kw_file_pair[file_index].push_back(row);
                    
						word.clear();
					}
					words_per_file.clear();
					file_name_with_path.clear();
				}
				file_name.clear();
			}

			closedir(pDir);
		}
		else
        {
			printf("Could not locate the directory...\n");
		}
	}
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
	}

    memset(keyword_trapdoor,0,TRAPDOOR_SIZE);
	memset(file_trapdoor,0,TRAPDOOR_SIZE);
	word.clear();
	delete pEntry;
	file_name.clear(); 
    file_name_with_path.clear();
	words_per_file.clear();
	delete kw_ex;
    delete dsse_trapdoor;
	
    return 0;
}

/**
 * Function Name: createEncrypted_matrix_from_kw_file_pair
 *
 * Description:
 * create the DSSE encrypted data structure from the keyword-file pairs extracted and write it to file named FILENAME_MATRIX (config.h)
 *
 * @param kw_file_pair: (input) list of keyword-file pair being extracted
 * @param row_counter_arr: (input) row counters
 * @param block_counter_arr: (input) column (block) counters
 * @param pKey: (input) key generated by genMasterKey which is used to encrypt DSSE data structure
 * @return	0 if successful
 */
int DSSE::createEncrypted_matrix_from_kw_file_pair(vector<vector<TYPE_INDEX>> &kw_file_pair, 
                                                    TYPE_COUNTER *row_counter_arr,
                                                    TYPE_COUNTER* block_counter_arr,
                                                    MasterKey *pKey)
{
    int n; 
    TYPE_INDEX curIdx;
    TYPE_INDEX size_row;
    TYPE_INDEX col, row, row_idx;
    TYPE_INDEX vector_idx = 0;
    TYPE_INDEX ii,jj;
    int bit_number;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;

    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    TYPE_INDEX block_idx;
    unsigned char row_key [BLOCK_CIPHER_SIZE];
    unsigned char row_key_input [BLOCK_CIPHER_SIZE];
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen();
    
    MatrixType** I = new MatrixType*[MATRIX_ROW_SIZE];
    for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
    {
        I[m] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I[m],0,MATRIX_PIECE_COL_SIZE);
    }
    
    block_idx = 0;
   
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
        {
            memset(I[m],0,MATRIX_PIECE_COL_SIZE);
        }
        for(curIdx  = MATRIX_PIECE_COL_SIZE*i,col=0; curIdx < MATRIX_PIECE_COL_SIZE * (i+1); col++,curIdx++)
        {
            for(bit_number = 0 ; bit_number < BYTE_SIZE; bit_number++)
            {
                vector_idx = curIdx * BYTE_SIZE + bit_number;
                for(row = 0, size_row = kw_file_pair[vector_idx].size(); row < size_row; row++)
                {
                    row_idx = kw_file_pair[vector_idx][row];
                    BIT_SET(&I[row_idx][col].byte_data,bit_number);
                }
            }
        }
        // encrypt block by block, there are two options:
        if(ENCRYPT_BLOCK_SIZE < BYTE_SIZE) // block size < byte size
        {
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&row_counter_arr[row],sizeof(row_counter_arr[row]));
                
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                block_idx = (MATRIX_PIECE_COL_SIZE*BYTE_SIZE/ENCRYPT_BLOCK_SIZE)*i; 
                for(jj = 0; jj < MATRIX_PIECE_COL_SIZE*BYTE_SIZE; jj+=ENCRYPT_BLOCK_SIZE,block_idx++)
                {
                    col = jj / BYTE_SIZE;
                    for(ii=0, bit_number = jj % BYTE_SIZE ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
                    {
                        if(BIT_CHECK(&I[row][col].byte_data,bit_number))
                            BIT_SET(&U[0],ii);
                        else
                            BIT_CLEAR(&U[0],ii);
                    }
                    memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                    memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&block_counter_arr[block_idx],sizeof(TYPE_COUNTER));
                    memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
                    // Encrypting the  matrix I using AES CTR 128 function
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    // Write the encryped row back to matrix I
                    for(ii=0,bit_number = jj % BYTE_SIZE ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
                    {
                    
                        if(BIT_CHECK(&V[0],ii))
                            BIT_SET(&I[row][col].byte_data,bit_number);
                        else
                            BIT_CLEAR(&I[row][col].byte_data,bit_number);
                    }
                }
            }
        }
        else // encrypt block size > byte_size
        {
            if(ENCRYPT_BLOCK_SIZE % BYTE_SIZE != 0)
            {
                printf("Invalid block size, it should be divisible by 8 and not larger than 128");
                exit(1);
            }
            
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                memcpy(row_key_input,&row,sizeof(row));
                memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&row_counter_arr[row],sizeof(row_counter_arr[row]));
                
                dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
                
                block_idx = (MATRIX_PIECE_COL_SIZE*BYTE_SIZE/ENCRYPT_BLOCK_SIZE)*i;
                for(col = 0; col < MATRIX_PIECE_COL_SIZE; col+=(ENCRYPT_BLOCK_SIZE/BYTE_SIZE),block_idx++)
                {
                    for(jj = col,ii=0; ii<ENCRYPT_BLOCK_SIZE/BYTE_SIZE;jj++, ii++)
                    {
                        U[ii] = I[row][jj].byte_data;
                    }
                    memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
                    memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&block_counter_arr[block_idx],sizeof(TYPE_COUNTER));
                    memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
                    // Encrypting the  matrix I using AES CTR 128 function
                    aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
                    for(jj = col,ii=0; ii<ENCRYPT_BLOCK_SIZE/BYTE_SIZE;jj++, ii++)
                    {
                        I[row][jj].byte_data = V[ii];
                    }
               } 
            }
        }
        //write the matrix to file by spliting it to smaller chunks
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE ; m +=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
    }
   
    for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
    {
        delete[] I[m];
    }
    delete[] I;
    return 0;
}

/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from the file named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE];
    memset(I_piece,0,MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE);
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename,gcsMatrixPiecePath,&I_piece[m*MATRIX_PIECE_COL_SIZE],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col+ (i*MATRIX_PIECE_COL_SIZE);
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                I[row][I_col_idx].byte_data = I_piece[row*MATRIX_PIECE_COL_SIZE+col].byte_data;
            }
        }
    }
    delete[] I_piece;
    return 0;
}


/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to the files named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE];
    memset(I_piece,0,MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE);
    for(int i = 0 ; i < n ; i++)
    {
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col+ (i*MATRIX_PIECE_COL_SIZE);
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                I_piece[row*MATRIX_PIECE_COL_SIZE+col].byte_data = I[row][I_col_idx].byte_data;
            }
        }
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I_piece[m*MATRIX_PIECE_COL_SIZE],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: createBlock_state_matrix_files
 *
 * Description:
 * Initialize the block state matrix and save it to files 
 * 
 * @return	0 if successful
 */
int DSSE::createBlock_state_matrix_files()
{
    int n; 
    Miscellaneous misc;
    n = (NUM_BLOCKS/BLOCK_STATE_PIECE_COL_SIZE);
    n = n /BYTE_SIZE;

    MatrixType** I_chunk = new MatrixType*[BLOCK_STATE_PIECE_ROW_SIZE];
    TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
    for(TYPE_INDEX k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        I_chunk[k] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        cout<<endl<<i<<"...."<<endl;
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE ; m +=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            for(int k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
            {
                memset(I_chunk[k],0,kk);
            }
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,I_chunk,BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
    }
    for(TYPE_INDEX k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        delete[] I_chunk[k]; 
    }
    delete[] I_chunk;
    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a small-piece of block state matrix from files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) Block state matrix
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS/BYTE_SIZE/BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType*[BLOCK_STATE_ROW_SIZE];
    
    TYPE_INDEX kk=BLOCK_STATE_PIECE_COL_SIZE ;

    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename,gcsMatrixPiecePath,&I_piece[m],BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col+ (i*kk);
            for(row = 0 ; row < BLOCK_STATE_ROW_SIZE ; row++)
            {
                I[row][I_col_idx] = I_piece[row][col];
            }
        }
    }
    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}


/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save block state matrix to files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) Block state matrix
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS/BYTE_SIZE/BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType*[BLOCK_STATE_ROW_SIZE];
    
    TYPE_INDEX kk=BLOCK_STATE_PIECE_COL_SIZE ;

    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col+ (i*kk);
            for(row = 0 ; row < BLOCK_STATE_ROW_SIZE ; row++)
            {
                I_piece[row][col] = I[row][I_col_idx] ;
            }
        }
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I_piece[m],BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
        
    }
    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: getBlock
 *
 * Description:
 * get the block data from the encrypted data structure, given a block index and the dimension
 *
 * @param block_index: (input) block index
 * @param dim: dimension (ROW or COL)
 * @param I_prime: (output) block data
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::getBlock( TYPE_INDEX index,    
                        int dim,
                        MatrixType** I,
                        MatrixType* I_prime)
{    
    TYPE_INDEX row, col;
    TYPE_INDEX I_prime_col;
    try
    {
        if(dim==COL)
        {
            TYPE_INDEX I_prime_idx = 0;
            TYPE_INDEX begin;
            TYPE_INDEX end;
            if(ENCRYPT_BLOCK_SIZE >= BYTE_SIZE)
            {
                begin = index * (ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
                end = begin + (ENCRYPT_BLOCK_SIZE/BYTE_SIZE);
                
                for(row = 0 ; row <MATRIX_ROW_SIZE; row++)
                {
                    for(col = begin; col < end;col++,I_prime_idx++)
                    {
                        I_prime[I_prime_idx].byte_data = I[row][col].byte_data;
                    }
                }
            }
            else
            {
                TYPE_INDEX I_bit_idx, I_prime_bit_idx;
                col = (index*ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
                begin = (index*ENCRYPT_BLOCK_SIZE) % BYTE_SIZE;
                end = begin + ENCRYPT_BLOCK_SIZE;
                for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
                {  
                    for(I_bit_idx = begin; I_bit_idx < end; I_bit_idx++,I_prime_idx++)
                    {
                        I_prime_col = I_prime_idx / BYTE_SIZE;
                        I_prime_bit_idx = I_prime_idx % BYTE_SIZE;
                        
                        if(BIT_CHECK(&I[row][col].byte_data,I_bit_idx))
                            BIT_SET(&I_prime[I_prime_col].byte_data,I_prime_bit_idx);
                        else
                            BIT_CLEAR(&I_prime[I_prime_col].byte_data,I_prime_bit_idx);
                    }
                }
            }
            
            
        }
        else
        {
            memcpy(I_prime,I[index],MATRIX_COL_SIZE);
        }
    }    
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    return 0;
}

/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only loads a single block of encrypted data structure appropriate with the index
 * @param I: (output) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx*ENCRYPT_BLOCK_SIZE)  / (MATRIX_PIECE_COL_SIZE* BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE)/(BYTE_SIZE));
        
        TYPE_INDEX n1 = (idx*ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE*BYTE_SIZE) /BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE-n1-c;
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename =  misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,c,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE) * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0],0,MATRIX_PIECE_COL_SIZE);
    
        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n  +=MATRIX_PIECE_COL_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,I_tmp,1,MATRIX_PIECE_COL_SIZE,m1,0,dim);
            memcpy(&I[0][n],I_tmp[0],MATRIX_PIECE_COL_SIZE);
            
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}


/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only saves a single block of encrypted data structure appropriate with the index
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx*ENCRYPT_BLOCK_SIZE)  / (MATRIX_PIECE_COL_SIZE* BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE)/(BYTE_SIZE));
        
        TYPE_INDEX n1 = (idx*ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE*BYTE_SIZE) /BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE-n1-c;
        
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,c,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE)  * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0],0,MATRIX_PIECE_COL_SIZE);
        
        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n +=MATRIX_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0],&I[0][n],MATRIX_PIECE_COL_SIZE);
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,I_tmp,1,MATRIX_PIECE_COL_SIZE,m1,0,dim);
            
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only save a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    if (dim == COL)
    {
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;
        
        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE*BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE-n1-1;
        
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" +misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,&I[m],BLOCK_STATE_PIECE_ROW_SIZE,1,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1=idx % BLOCK_STATE_PIECE_ROW_SIZE;
        
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[BLOCK_STATE_PIECE_COL_SIZE];
        memset(I_tmp[0],0,BLOCK_STATE_PIECE_COL_SIZE);
        
        for(TYPE_INDEX n = 0; n < NUM_BLOCKS/BYTE_SIZE; n +=BLOCK_STATE_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0],&I[0][n],BLOCK_STATE_PIECE_COL_SIZE);
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,I_tmp,1,BLOCK_STATE_PIECE_COL_SIZE,m1,0,dim);
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only load a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;
        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE*BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE-n1-1;
        
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,&I[m],BLOCK_STATE_PIECE_ROW_SIZE,1,n1,n2,dim);
            
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % BLOCK_STATE_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
        I_tmp[0] = new MatrixType[kk];
        memset(I_tmp[0],0,kk);
        
        for(TYPE_INDEX n = 0; n < NUM_BLOCKS/BYTE_SIZE; n  +=BLOCK_STATE_PIECE_COL_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,I_tmp,1,kk,m1,0,dim);
            memcpy(&I[0][n],I_tmp[0],kk);
        }
    
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

